var searchIndex = {};
searchIndex["liquery_file"] = {"doc":"# liquery-file\nA library to make queryable files for the liquery `Queryable`\ntrait.","items":[[3,"QueryFile","liquery_file","A Queryable instance of a file",null,null],[11,"new","","Get a new instance of a QueryFile",0,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"query","","",0,null]],"paths":[[3,"QueryFile"]]};
searchIndex["mime_guess"] = {"doc":"Guessing of MIME types by file extension.","items":[[5,"guess_mime_type","mime_guess","Guess the MIME type of `path` by its extension (as defined by `Path::extension()`).",null,{"inputs":[{"name":"p"}],"output":{"name":"mime"}}],[5,"guess_mime_type_opt","","Guess the MIME type of `path` by its extension (as defined by `Path::extension()`).",null,{"inputs":[{"name":"p"}],"output":{"name":"option"}}],[5,"get_mime_type","","Get the MIME type associated with a file extension.",null,{"inputs":[{"name":"str"}],"output":{"name":"mime"}}],[5,"get_mime_type_opt","","Get the MIME type associated with a file extension.",null,{"inputs":[{"name":"str"}],"output":{"name":"option"}}],[5,"get_mime_type_str","","Get the MIME type string associated with a file extension. Case-insensitive.",null,{"inputs":[{"name":"str"}],"output":{"name":"option"}}],[5,"get_mime_extensions","","Get a list of known extensions for a given `Mime`.",null,{"inputs":[{"name":"mime"}],"output":{"name":"option"}}],[5,"get_mime_extensions_str","","Get a list of known extensions for a MIME type string.",null,{"inputs":[{"name":"str"}],"output":{"name":"option"}}],[5,"get_extensions","","Get the extensions for a given top-level and sub-level of a MIME type\n(`{toplevel}/{sublevel}`).",null,{"inputs":[{"name":"str"},{"name":"str"}],"output":{"name":"option"}}],[5,"octet_stream","","Get the MIME type for `application/octet-stream` (generic binary stream)",null,{"inputs":[],"output":{"name":"mime"}}]],"paths":[]};
searchIndex["phf"] = {"doc":"Compile time optimized maps and sets.","items":[[11,"phf_hash","collections::string","",0,null],[11,"phf_hash","collections::vec","",1,null],[11,"phf_hash","unicase","",2,null],[8,"PhfHash","phf","A trait implemented by types which can be used in PHF data structures.",null,null],[10,"phf_hash","","Feeds the value into the state given, updating the hasher as necessary.",3,null],[11,"phf_hash_slice","","Feeds a slice of this type into the state provided.",3,null],[3,"Map","","An immutable map constructed at compile time.",null,null],[3,"Set","","An immutable set constructed at compile time.",null,null],[3,"OrderedMap","","An order-preserving immutable map constructed at compile time.",null,null],[3,"OrderedSet","","An order-preserving immutable set constructed at compile time.",null,null],[0,"map","","An immutable map constructed at compile time.",null,null],[3,"Map","phf::map","An immutable map constructed at compile time.",null,null],[3,"Entries","","An iterator over the key/value pairs in a `Map`.",null,null],[3,"Keys","","An iterator over the keys in a `Map`.",null,null],[3,"Values","","An iterator over the values in a `Map`.",null,null],[11,"fmt","","",4,null],[11,"index","","",4,null],[11,"is_empty","","Returns true if the `Map` is empty.",4,null],[11,"len","","Returns the number of entries in the `Map`.",4,null],[11,"contains_key","","Determines if `key` is in the `Map`.",4,null],[11,"get","","Returns a reference to the value that `key` maps to.",4,null],[11,"get_key","","Returns a reference to the map&#39;s internal static instance of the given\nkey.",4,null],[11,"get_entry","","Like `get`, but returns both the key and the value.",4,null],[11,"entries","","Returns an iterator over the key/value pairs in the map.",4,null],[11,"keys","","Returns an iterator over the keys in the map.",4,null],[11,"values","","Returns an iterator over the values in the map.",4,null],[11,"next","","",5,null],[11,"size_hint","","",5,null],[11,"next_back","","",5,null],[11,"next","","",6,null],[11,"size_hint","","",6,null],[11,"next_back","","",6,null],[11,"next","","",7,null],[11,"size_hint","","",7,null],[11,"next_back","","",7,null],[0,"set","phf","An immutable set constructed at compile time.",null,null],[3,"Set","phf::set","An immutable set constructed at compile time.",null,null],[3,"Iter","","An iterator over the values in a `Set`.",null,null],[11,"fmt","","",8,null],[11,"len","","Returns the number of elements in the `Set`.",8,null],[11,"is_empty","","Returns true if the `Set` contains no elements.",8,null],[11,"get_key","","Returns a reference to the set&#39;s internal static instance of the given\nkey.",8,null],[11,"contains","","Returns true if `value` is in the `Set`.",8,null],[11,"iter","","Returns an iterator over the values in the set.",8,null],[11,"is_disjoint","","Returns true if `other` shares no elements with `self`.",8,null],[11,"is_subset","","Returns true if `other` contains all values in `self`.",8,null],[11,"is_superset","","Returns true if `self` contains all values in `other`.",8,null],[11,"next","","",9,null],[11,"size_hint","","",9,null],[11,"next_back","","",9,null],[0,"ordered_map","phf","An order-preserving immutable map constructed at compile time.",null,null],[3,"OrderedMap","phf::ordered_map","An order-preserving immutable map constructed at compile time.",null,null],[3,"Entries","","An iterator over the entries in a `OrderedMap`.",null,null],[3,"Keys","","An iterator over the keys in a `OrderedMap`.",null,null],[3,"Values","","An iterator over the values in a `OrderedMap`.",null,null],[11,"fmt","","",10,null],[11,"index","","",10,null],[11,"len","","Returns the number of entries in the `Map`.",10,null],[11,"is_empty","","Returns true if the `Map` is empty.",10,null],[11,"get","","Returns a reference to the value that `key` maps to.",10,null],[11,"get_key","","Returns a reference to the map&#39;s internal static instance of the given\nkey.",10,null],[11,"contains_key","","Determines if `key` is in the `Map`.",10,null],[11,"get_index","","Returns the index of the key within the list used to initialize\nthe ordered map.",10,null],[11,"index","","Returns references to both the key and values at an index\nwithin the list used to initialize the ordered map. See `.get_index(key)`.",10,null],[11,"get_entry","","Like `get`, but returns both the key and the value.",10,null],[11,"entries","","Returns an iterator over the key/value pairs in the map.",10,null],[11,"keys","","Returns an iterator over the keys in the map.",10,null],[11,"values","","Returns an iterator over the values in the map.",10,null],[11,"next","","",11,null],[11,"size_hint","","",11,null],[11,"next_back","","",11,null],[11,"next","","",12,null],[11,"size_hint","","",12,null],[11,"next_back","","",12,null],[11,"next","","",13,null],[11,"size_hint","","",13,null],[11,"next_back","","",13,null],[0,"ordered_set","phf","An order-preserving immutable set constructed at compile time.",null,null],[3,"OrderedSet","phf::ordered_set","An order-preserving immutable set constructed at compile time.",null,null],[3,"Iter","","An iterator over the values in a `OrderedSet`.",null,null],[11,"fmt","","",14,null],[11,"len","","Returns the number of elements in the `OrderedSet`.",14,null],[11,"is_empty","","Returns true if the `OrderedSet` contains no elements.",14,null],[11,"get_key","","Returns a reference to the set&#39;s internal static instance of the given\nkey.",14,null],[11,"get_index","","Returns the index of the key within the list used to initialize\nthe ordered set.",14,null],[11,"index","","Returns a reference to the key at an index\nwithin the list used to initialize the ordered set. See `.get_index(key)`.",14,null],[11,"contains","","Returns true if `value` is in the `Set`.",14,null],[11,"iter","","Returns an iterator over the values in the set.",14,null],[11,"is_disjoint","","Returns true if `other` shares no elements with `self`.",14,null],[11,"is_subset","","Returns true if `other` contains all values in `self`.",14,null],[11,"is_superset","","Returns true if `self` contains all values in `other`.",14,null],[11,"next","","",15,null],[11,"size_hint","","",15,null],[11,"next_back","","",15,null]],"paths":[[3,"String"],[3,"Vec"],[3,"UniCase"],[8,"PhfHash"],[3,"Map"],[3,"Entries"],[3,"Keys"],[3,"Values"],[3,"Set"],[3,"Iter"],[3,"OrderedMap"],[3,"Entries"],[3,"Keys"],[3,"Values"],[3,"OrderedSet"],[3,"Iter"]]};
searchIndex["phf_shared"] = {"doc":"","items":[[5,"displace","phf_shared","",null,{"inputs":[{"name":"u32"},{"name":"u32"},{"name":"u32"},{"name":"u32"}],"output":{"name":"u32"}}],[5,"split","","",null,null],[5,"hash","","`key` is from `phf_generator::HashState::key`.",null,{"inputs":[{"name":"t"},{"name":"u64"}],"output":{"name":"u64"}}],[5,"get_index","","Return an index into `phf_generator::HashState::map`.",null,null],[8,"PhfHash","","A trait implemented by types which can be used in PHF data structures.",null,null],[10,"phf_hash","","Feeds the value into the state given, updating the hasher as necessary.",0,null],[11,"phf_hash_slice","","Feeds a slice of this type into the state provided.",0,null],[11,"phf_hash","collections::string","",1,null],[11,"phf_hash","collections::vec","",2,null],[11,"phf_hash","unicase","",3,null]],"paths":[[8,"PhfHash"],[3,"String"],[3,"Vec"],[3,"UniCase"]]};
searchIndex["mime"] = {"doc":"# Mime","items":[[3,"Mime","mime","Mime, or Media Type. Encapsulates common registers types.",null,null],[12,"0","","",0,null],[12,"1","","",0,null],[12,"2","","",0,null],[4,"TopLevel","","",null,null],[13,"Star","","",1,null],[13,"Text","","",1,null],[13,"Image","","",1,null],[13,"Audio","","",1,null],[13,"Video","","",1,null],[13,"Application","","",1,null],[13,"Multipart","","",1,null],[13,"Message","","",1,null],[13,"Model","","",1,null],[13,"Ext","","",1,null],[4,"SubLevel","","",null,null],[13,"Star","","",2,null],[13,"Plain","","",2,null],[13,"Html","","",2,null],[13,"Xml","","",2,null],[13,"Javascript","","",2,null],[13,"Css","","",2,null],[13,"EventStream","","",2,null],[13,"Json","","",2,null],[13,"WwwFormUrlEncoded","","",2,null],[13,"Msgpack","","",2,null],[13,"OctetStream","","",2,null],[13,"FormData","","",2,null],[13,"Png","","",2,null],[13,"Gif","","",2,null],[13,"Bmp","","",2,null],[13,"Jpeg","","",2,null],[13,"Ext","","",2,null],[4,"Attr","","",null,null],[13,"Charset","","",3,null],[13,"Boundary","","",3,null],[13,"Q","","",3,null],[13,"Ext","","",3,null],[4,"Value","","",null,null],[13,"Utf8","","",4,null],[13,"Ext","","",4,null],[6,"Param","","",null,null],[11,"hash","","",0,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"hash","","",1,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"as_str","","",1,null],[11,"deref","","",1,null],[11,"eq","","",1,null],[11,"eq","","",1,null],[11,"eq","","",1,null],[11,"eq","","",1,null],[11,"eq","collections::string","",5,null],[11,"fmt","mime","",1,null],[11,"from_str","","",1,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"hash","","",2,null],[11,"fmt","","",2,null],[11,"clone","","",2,null],[11,"as_str","","",2,null],[11,"deref","","",2,null],[11,"eq","","",2,null],[11,"eq","","",2,null],[11,"eq","","",2,null],[11,"eq","","",2,null],[11,"eq","collections::string","",5,null],[11,"fmt","mime","",2,null],[11,"from_str","","",2,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"hash","","",3,null],[11,"fmt","","",3,null],[11,"clone","","",3,null],[11,"as_str","","",3,null],[11,"deref","","",3,null],[11,"eq","","",3,null],[11,"eq","","",3,null],[11,"eq","","",3,null],[11,"eq","","",3,null],[11,"eq","collections::string","",5,null],[11,"fmt","mime","",3,null],[11,"from_str","","",3,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"hash","","",4,null],[11,"fmt","","",4,null],[11,"clone","","",4,null],[11,"as_str","","",4,null],[11,"deref","","",4,null],[11,"eq","","",4,null],[11,"eq","","",4,null],[11,"eq","","",4,null],[11,"eq","","",4,null],[11,"eq","collections::string","",5,null],[11,"fmt","mime","",4,null],[11,"from_str","","",4,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",0,null],[11,"get_param","","",0,null],[11,"from_str","","",0,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[14,"mime!","","Easily create a Mime without having to import so many enums.",null,null]],"paths":[[3,"Mime"],[4,"TopLevel"],[4,"SubLevel"],[4,"Attr"],[4,"Value"],[3,"String"]]};
searchIndex["log"] = {"doc":"A lightweight logging facade.","items":[[3,"LogRecord","log","The &quot;payload&quot; of a log message.",null,null],[3,"LogMetadata","","Metadata about a log message.",null,null],[3,"LogLocation","","The location of a log message.",null,null],[3,"MaxLogLevelFilter","","A token providing read and write access to the global maximum log level\nfilter.",null,null],[3,"SetLoggerError","","The type returned by `set_logger` if `set_logger` has already been called.",null,null],[3,"ShutdownLoggerError","","The type returned by `shutdown_logger_raw` if `shutdown_logger_raw` has\nalready been called or if `set_logger_raw` has not been called yet.",null,null],[4,"LogLevel","","An enum representing the available verbosity levels of the logging framework",null,null],[13,"Error","","The &quot;error&quot; level.",0,null],[13,"Warn","","The &quot;warn&quot; level.",0,null],[13,"Info","","The &quot;info&quot; level.",0,null],[13,"Debug","","The &quot;debug&quot; level.",0,null],[13,"Trace","","The &quot;trace&quot; level.",0,null],[4,"LogLevelFilter","","An enum representing the available verbosity level filters of the logging\nframework.",null,null],[13,"Off","","A level lower than all log levels.",1,null],[13,"Error","","Corresponds to the `Error` log level.",1,null],[13,"Warn","","Corresponds to the `Warn` log level.",1,null],[13,"Info","","Corresponds to the `Info` log level.",1,null],[13,"Debug","","Corresponds to the `Debug` log level.",1,null],[13,"Trace","","Corresponds to the `Trace` log level.",1,null],[5,"max_log_level","","Returns the current maximum log level.",null,{"inputs":[],"output":{"name":"loglevelfilter"}}],[5,"set_logger","","Sets the global logger.",null,{"inputs":[{"name":"m"}],"output":{"name":"result"}}],[5,"set_logger_raw","","Sets the global logger from a raw pointer.",null,{"inputs":[{"name":"m"}],"output":{"name":"result"}}],[5,"shutdown_logger","","Shuts down the global logger.",null,{"inputs":[],"output":{"name":"result"}}],[5,"shutdown_logger_raw","","Shuts down the global logger.",null,{"inputs":[],"output":{"name":"result"}}],[8,"Log","","A trait encapsulating the operations required of a logger",null,null],[10,"enabled","","Determines if a log message with the specified metadata would be\nlogged.",2,null],[10,"log","","Logs the `LogRecord`.",2,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"eq","","",0,null],[11,"partial_cmp","","",0,null],[11,"partial_cmp","","",0,null],[11,"cmp","","",0,null],[11,"from_str","","",0,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",0,null],[11,"max","","Returns the most verbose logging level.",0,{"inputs":[],"output":{"name":"loglevel"}}],[11,"to_log_level_filter","","Converts the `LogLevel` to the equivalent `LogLevelFilter`.",0,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"eq","","",1,null],[11,"eq","","",1,null],[11,"partial_cmp","","",1,null],[11,"partial_cmp","","",1,null],[11,"cmp","","",1,null],[11,"from_str","","",1,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",1,null],[11,"max","","Returns the most verbose logging level filter.",1,{"inputs":[],"output":{"name":"loglevelfilter"}}],[11,"to_log_level","","Converts `self` to the equivalent `LogLevel`.",1,null],[11,"args","","The message body.",3,null],[11,"metadata","","Metadata about the log directive.",3,null],[11,"location","","The location of the log directive.",3,null],[11,"level","","The verbosity level of the message.",3,null],[11,"target","","The name of the target of the directive.",3,null],[11,"level","","The verbosity level of the message.",4,null],[11,"target","","The name of the target of the directive.",4,null],[11,"fmt","","",5,null],[11,"clone","","",5,null],[11,"module_path","","The module path of the message.",5,null],[11,"file","","The source file containing the message.",5,null],[11,"line","","The line containing the message.",5,null],[11,"fmt","","",6,null],[11,"get","","Gets the current maximum log level filter.",6,null],[11,"set","","Sets the maximum log level.",6,null],[11,"fmt","","",7,null],[11,"fmt","","",7,null],[11,"description","","",7,null],[11,"fmt","","",8,null],[11,"fmt","","",8,null],[11,"description","","",8,null],[14,"log!","","The standard logging macro.",null,null],[14,"error!","","Logs a message at the error level.",null,null],[14,"warn!","","Logs a message at the warn level.",null,null],[14,"info!","","Logs a message at the info level.",null,null],[14,"debug!","","Logs a message at the debug level.",null,null],[14,"trace!","","Logs a message at the trace level.",null,null],[14,"log_enabled!","","Determines if a message logged at the specified level in that module will\nbe logged.",null,null]],"paths":[[4,"LogLevel"],[4,"LogLevelFilter"],[8,"Log"],[3,"LogRecord"],[3,"LogMetadata"],[3,"LogLocation"],[3,"MaxLogLevelFilter"],[3,"SetLoggerError"],[3,"ShutdownLoggerError"]]};
searchIndex["liquery"] = {"doc":"","items":[[3,"QueryReturn","liquery","Result of a query",null,null],[3,"Query","","A parsed query ready for use with a `Context` and `Queryable`",null,null],[4,"ParseError","","Errors found in parsing query",null,null],[13,"UnknownEscape","","Unknown escape sequence.\nString contains the sequece",0,null],[13,"EscapeAtEndOfQuery","","Escape squence at end of query",0,null],[13,"VariableMissingClosing","","Variable is missing closing character",0,null],[13,"FuncMissingParameter","","Function is missing start of parameters",0,null],[13,"FuncParameterNotClosed","","Function parameters is missing closing character",0,null],[13,"EndOfQuery","","End of Query",0,null],[4,"EvalError","","Errors found while evaluating query",null,null],[13,"FunctionNotFound","","Function used is not in the current context\nString passed is the function name",1,null],[4,"Token","","AST tokens for the query string",null,null],[13,"Text","","Plain text with resolved escapes",2,null],[13,"Variable","","A named variable",2,null],[13,"Function","","A named function that has arguments",2,null],[13,"Scope","","A level of scope",2,null],[11,"fmt","","",0,null],[11,"parse","","",3,{"inputs":[{"name":"string"}],"output":{"name":"parseresult"}}],[11,"from_str","","",3,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",1,null],[11,"eval","","Evaluate the query with a queryable object to be based off and a\ncontext",3,null],[11,"eval","","Evaluate a token",2,null],[11,"query","std::collections::hash::map","",4,null],[11,"get_func","","",4,null],[11,"query","collections::btree::map","",5,null],[11,"get_func","","",5,null],[6,"ParseResult","liquery","",null,null],[6,"EvalResult","","",null,null],[6,"EvalFunc","","The General function signature for formatting function calls\n&gt; note: very likely to change",null,null],[8,"Context","","Trait describing an object that contains a dictionary of functions",null,null],[10,"get_func","","",6,null],[8,"Queryable","","Trait describing an object that can be queried for variables",null,null],[10,"query","","",7,null],[11,"fmt","","",3,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"fmt","","",2,null]],"paths":[[4,"ParseError"],[4,"EvalError"],[4,"Token"],[3,"Query"],[3,"HashMap"],[3,"BTreeMap"],[8,"Context"],[8,"Queryable"]]};
searchIndex["unicase"] = {"doc":"# Case","items":[[3,"UniCase","unicase","Case Insensitive wrapper of strings.",null,null],[12,"0","","",0,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"partial_cmp","","",0,null],[11,"cmp","","",0,null],[11,"as_ref","","",0,null],[11,"fmt","","",0,null],[11,"eq","","",0,null],[11,"from_str","","",0,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"hash","","",0,null],[11,"from","","",0,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"into","","",0,null],[11,"into","","",0,null]],"paths":[[3,"UniCase"]]};
initSearch(searchIndex);
